package de.tubs.cs.ias.plotalyzer

import de.halcony.argparse.{OptionalValue, Parser, ParsingException, ParsingResult}
import de.tubs.cs.ias.plotalyzer.analysis.consentdialog.{ConsentDialogAnalysis, SpotcheckGenerator}
import de.tubs.cs.ias.plotalyzer.analysis.tcfdetection.{DynamicTCFDetection, StaticTCFDetection, TCFDetectionConf}
import de.tubs.cs.ias.plotalyzer.analysis.trafficanalysis.filter.HostPathFilterTypes.{EXODUS, GENERIC}
import de.tubs.cs.ias.plotalyzer.analysis.trafficanalysis.filter.TrafficFilter
import de.tubs.cs.ias.plotalyzer.analysis.trafficanalysis.{RequestTrackingEndpointAnalysis, TrafficCollectionAnalysisConfig, TrafficSummary}
import de.tubs.cs.ias.plotalyzer.analysis.{BasicExperimentSummary, ExperimentErrorSummary, FailedAnalysisSummary}
import de.tubs.cs.ias.plotalyzer.database.entities.{Experiment, InterfaceAnalysis}
import de.tubs.cs.ias.plotalyzer.database.{Database, DatabaseConf}
import de.tubs.cs.ias.plotalyzer.json.AppmiRankingListSet
import de.tubs.cs.ias.plotalyzer.utility.Time
import spray.json.{JsArray, JsNumber, JsObject, JsString, JsValue, JsonParser}
import wvlet.log.LogSupport

import java.io.{BufferedWriter, File, FileWriter}
import scala.io.Source

object Plotalyzer extends LogSupport {

  val parser: Parser = Parser(
    "plotalyzer",
    "takes a scala-appanalyzer database and generates json for further processing")
    .addPositional("database-conf", "a json containing the database conf")
    .addPositional("id", "the id of the experiment to analyze")
    .addPositional(
      "out",
      "the path to print the result into (folder for screenshot json for data)")
    .addSubparser(
      Parser("appMetaData","using the manifest and ranking lists create a comprehensive meta data file")
        .addPositional("manifest","the manifest.json")
        .addPositional("rankingListFolder","the folder with the ranking lists")
        .addDefault[ParsingResult => JsValue]("func",generateAppMetaDataMain)
    )
    .addSubparser(
      Parser("generateOnlySet","given a app meta data json filter for apps matching specifications")
        .addPositional("manifest","the manifest.json to be filtered generated by the appMetaData action")
        .addOptional("categories","c","category",None,"app belongs to a certain category (csv list)")
        .addOptional("bestCategory","b","best-category",None,"the apps best category")
        .addOptional("rank","r","rank",None,"the apps rank either for the provided categories or if not provided best rank is used")
        .addDefault[ParsingResult => JsValue]("func",printFilteredAppManifestMain)
    )
    .addSubparser(Parser("tcfDetection","analyze set of apps for any tcf indicating values")
      .addOptional("only","o","only",None,"only analyze the provided apps")
      .addOptional("tcfConfig","c","config", Some("./resources/tcfDetection/TCFConfig.json"))
      .addSubparser(Parser("dynamic","perform analysis on dynamically collected data")
        .addDefault[ParsingResult => JsValue]("func", generateDynamicTcfSummaryMain))
      .addSubparser(Parser("static","use statically extracted file data")
        .addPositional("os","the operating system for which the binary initially was {Android,iOS}")
        .addPositional("json","the json containing the extracted files per app")
        .addDefault[ParsingResult => JsValue]("func",generateStaticTcfSummaryMain))
    )
    .addSubparser(
      Parser("screenshot", "dump all screenshots associated with an app")
        .addPositional("app", "the app id")
        .addDefault[ParsingResult => JsValue]("func", dumpScreenshotsMain))
    .addSubparser(Parser("summary", "high level summary of the experiment")
      .addDefault[ParsingResult => JsValue]("func",
                                            generateExperimentSummaryMain))
    .addSubparser(Parser("error", "summarize encountered errors")
      .addDefault[ParsingResult => JsValue]("func", generateErrorSummaryMain))
    .addSubparser(Parser("failures","summarize failed analysis and apps")
      .addDefault[ParsingResult => JsValue]("func",generateFailureSummaryMain))
    .addSubparser(
      Parser("trafficSummary", "list all the request collected during the experiment")
        .addOptional("timespan","s","timespan-seconds",None,"how many seconds of the experiment since start are part of the summary")
        .addOptional("filterJson","j","filter-file",None,"path to an exodus tracker json for filtering")
        .addOptional("filterType","t","filter-type",None,"what type of request filter {Exodus,Generic}")
        .addOptional("only","o","only",None,"only analyze the provided apps")
        .addDefault[ParsingResult => JsValue]("func",generateTrafficSummary))
    .addSubparser(
      Parser("trafficCollection", "analyze the collected traffic")
        .addOptional("trafficConfig",
                     "c",
                     "config",
                     Some("./resources/trafficCollection/config.json"))
        .addOptional("only","o","only",None,"only analyze the provided apps")
        .addDefault[ParsingResult => JsValue](
          "func",
          generateTrafficCollectionAnalysisMain))
    .addSubparser(
      Parser("consentDialog", "analyze a consent dialog analysis experiment")
        .addOptional("analysisConfig",
                     "c",
                     "config",
                     Some("./resources/consentDialog/config.json"),
                     "the config for the consent dialog analysis")
        .addOptional("only","o","only",None,"only analyze the provided apps")
        .addSubparser(Parser("analyze","perform an analysis")
          .addDefault[ParsingResult => JsValue](
            "func",
            generateConsentDialogAnalysisMain))
        .addSubparser(Parser("spotcheck","perform an spotcheck of the analysis results")
          .addOptional("include","i","include",None,"path to a file containing line by line list of to be included apps")
          .addOptional("fill","f","fill",None,"amount of apps that should be spot checked")
          .addDefault[ParsingResult => JsValue]("func",generateConsentDialogAnalysisSpotcheckMain)))

  def main(args: Array[String]): Unit = {
    try {
      val pargs = parser.parse(args)
      val ret: Option[JsValue] = Option(
        pargs.getValue[ParsingResult => JsValue]("func")(pargs))
      ret match {
        case Some(value) =>
          val out = new BufferedWriter(
            new FileWriter(new File(pargs.getValue[String]("out"))))
          try {
            out.write(value.prettyPrint)
          } finally {
            out.flush()
            out.close()
          }
        case None =>
      }
    } catch {
      case x: ParsingException => println(x.getMessage())
    }
  }

  private def getOnlyApps(pargs : ParsingResult) : Set[String] = {
    pargs.get[OptionalValue[String]]("only").value match {
      case Some(value) =>
        if(new File(value).exists()) {
          val source = Source.fromFile(value)
          try {
            source.getLines().map(_.trim).toSet
          } finally {
            source.close()
          }
        } else {
          value.split(',').toSet
        }
      case None =>
        Set()
    }
  }

  private def getDatabaseConnection(pargs: ParsingResult): Database = {
    val conf = DatabaseConf.read(pargs.getValue[String]("database-conf"))
    new Database(conf.host, conf.port, conf.user, conf.pwd, conf.database)
  }

  private def generateAppMetaDataMain(pargs : ParsingResult) : JsValue = {
    val manifest = pargs.getValue[String]("manifest")
    val listFolder = pargs.getValue[String]("rankingListFolder")
    JsObject(AppmiRankingListSet.getAppSummary(listFolder,manifest).map(elem => elem.getId -> elem.toJson).toMap)
  }

  private def printFilteredAppManifestMain(pargs : ParsingResult) : JsValue = {
    val categories : Set[String] =
      pargs.getValueOrElse[String]("categories","NOTHING")
        .split(",").toSet.filterNot(_ == "NOTHING")
    val bestCategory : Option[String] = pargs.get[OptionalValue[String]]("bestCategory").value
    val rank : Option[Int] = pargs.get[OptionalValue[String]]("rank").value match {
      case Some(value) => Some(value.toInt)
      case None => None
    }
    val source = Source.fromFile(pargs.getValue[String]("manifest"))
    val json : JsObject = try {
      JsonParser(source.mkString).asJsObject
    } finally {
      source.close()
    }
    val out = new FileWriter(new File(pargs.getValue[String]("out")))
    try {
      json.fields.foreach {
        case (appId, appMetaData) =>
          try {
            val metaDataObj = appMetaData.asJsObject
            if (categories.isEmpty) {
              if ((bestCategory.isEmpty || bestCategory.get == metaDataObj.fields("bestCategory").asInstanceOf[JsString].value) &&
                (rank.isEmpty || rank.get >= metaDataObj.fields("bestRank").asInstanceOf[JsNumber].value)) {
                out.write(appId + "\n")
              }
            } else {
              if (bestCategory.nonEmpty) warn("categories is non empty, ignoring best category")
              if (metaDataObj.fields("categories").asJsObject.fields.exists {
                case (category, catRank) =>
                  categories.contains(category) && (rank.isEmpty || rank.get >= catRank.asInstanceOf[JsNumber].value)
              })
                out.write(appId + "\n")
            }
          } catch {
            case err : Throwable => error(s"$appId : ${err.getMessage}")
          }
      }
    } finally {
      out.flush()
      out.close()
    }
    null
  }


  private def generateTrafficSummary(pargs : ParsingResult) : JsValue = {
    val experimentId = pargs.getValue[String]("id")
    implicit val database : Database = getDatabaseConnection(pargs)
    val experiment : Experiment = Experiment(experimentId)
    val timespan : Option[TrafficFilter] = pargs.get[OptionalValue[String]]("timespan-seconds").value match {
      case Some(value) => Some(TrafficFilter.getTimeFilter(value.toLong))
      case None => None
    }
    val hostName : Option[TrafficFilter] = (pargs.get[OptionalValue[String]]("filterJson").value,pargs.get[OptionalValue[String]]("filterJson").value) match {
      case (Some(json),Some(ftype)) =>
        ftype match {
          case "Exodus" => Some(TrafficFilter.getHostPathFilter(json,EXODUS))
          case "Generic" => Some(TrafficFilter.getHostPathFilter(json,GENERIC))
          case x => throw new RuntimeException(s"the filter type $x is unknown")
        }
      case (None,None) => None
      case _ => throw new RuntimeException("-j/--filter-file and -t/--filter-type have to be used together")
    }
    val only = getOnlyApps(pargs)
    TrafficSummary(experiment,List(timespan,hostName).filter(_.nonEmpty).map(_.get),only).toJson
  }

  private def generateExperimentSummaryMain(pargs: ParsingResult): JsValue = {
    val experimentId = pargs.getValue[String]("id")
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    JsObject(
      "id" -> JsNumber(experiment.getId),
      "created" -> JsString(Time.format(experiment.getCreated)),
      "description" -> JsString(experiment.getDescription),
      "basicSummary" -> BasicExperimentSummary(experiment).toJson
    )
  }

  private def generateErrorSummaryMain(pargs: ParsingResult): JsValue = {
    val experimentId = pargs.getValue[String]("id")
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    JsObject(
      "id" -> JsNumber(experiment.getId),
      "created" -> JsString(Time.format(experiment.getCreated)),
      "description" -> JsString(experiment.getDescription),
      "errorSummary" -> ExperimentErrorSummary(experiment).toJson
    )
  }

  private def generateConsentDialogAnalysisMain(
      pargs: ParsingResult): JsValue = {
    val experimentId = pargs.getValue[String]("id")
    val config = pargs.getValue[String]("analysisConfig")
    val only = getOnlyApps(pargs)
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    val res = ConsentDialogAnalysis(experiment, config, only)
    JsObject(
      "_failed" -> JsArray(res.getFailedAnalysisIds.map(elem => JsNumber(elem)).toVector),
      "id" -> JsNumber(experiment.getId),
      "created" -> JsString(Time.format(experiment.getCreated)),
      "description" -> JsString(experiment.getDescription),
      "consentDialogAnalysis" -> res.toJson
    )
  }

  private def generateConsentDialogAnalysisSpotcheckMain(pargs : ParsingResult) : JsValue = {
    val experimentId = pargs.getValue[String]("id")
    val config = pargs.getValue[String]("analysisConfig")
    val only = getOnlyApps(pargs)
    val include = pargs.get[OptionalValue[String]]("include").value match {
      case Some(value) =>
        val source = Source.fromFile(value)
        try {
          source.getLines().toList
        } finally {
          source.close()
        }
      case None => List()
    }
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    val res = ConsentDialogAnalysis(experiment, config, only)
    val out = pargs.getValue[String]("out")
    val fill = pargs.get[OptionalValue[String]]("fill").value match {
      case Some(value) => Some(value.toInt)
      case None => None
    }
    info(s"generating spotcheck for $fill apps including ${include.length} predefined")
    SpotcheckGenerator.generate(res,include,fill,out)
    null
  }

  private def generateTrafficCollectionAnalysisMain(
      pargs: ParsingResult): JsValue = {
    val experimentId = pargs.getValue[String]("id")
    val only = getOnlyApps(pargs)
    val confPath = pargs.getValue[String]("trafficConfig")
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    JsObject(
      "id" -> JsNumber(experiment.getId),
      "created" -> JsString(Time.format(experiment.getCreated)),
      "description" -> JsString(experiment.getDescription),
      "trafficTrackingEndpoints" -> RequestTrackingEndpointAnalysis(
        experiment,
        TrafficCollectionAnalysisConfig.get(confPath),
        only).toJson
    )
  }

  private def generateFailureSummaryMain(pargs : ParsingResult) : JsValue = {
    val experimentId = pargs.getValue[String]("id")
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    JsObject(
      "id" -> JsNumber(experiment.getId),
      "created" -> JsString(Time.format(experiment.getCreated)),
      "description" -> JsString(experiment.getDescription),
      "failureSummary" -> FailedAnalysisSummary(experiment).toJson
    )
  }

  private def generateStaticTcfSummaryMain(pargs : ParsingResult) : JsValue = {
    val experimentId = pargs.getValue[String]("id")
    val filePath = pargs.getValue[String]("json")
    val only = getOnlyApps(pargs)
    val conf = TCFDetectionConf.apply(pargs.getValue[String]("tcfConfig"))
    val os = pargs.getValue[String]("os")
    JsObject(
      "id" -> JsNumber(experimentId),
      "type" -> JsString("static"),
      "summary" -> new StaticTCFDetection(filePath,conf,os,only).toJson
    )
  }

  private def generateDynamicTcfSummaryMain(pargs: ParsingResult): JsValue = {
    val experimentId = pargs.getValue[String]("id")
    implicit val database: Database = getDatabaseConnection(pargs)
    val experiment: Experiment = Experiment(experimentId)
    val only = getOnlyApps(pargs)
    val config = pargs.getValue[String]("tcfConfig")
    JsObject(
      "id" -> JsNumber(experimentId),
      "type" -> JsString("dynamic"),
      "summary" -> DynamicTCFDetection(experiment, TCFDetectionConf.apply(config), only).toJson
    )
  }

  private def dumpScreenshotsMain(pargs: ParsingResult): JsValue = {
    implicit val database: Database = getDatabaseConnection(pargs)
    val experimentId = pargs.getValue[String]("id")
    val app = pargs.getValue[String]("app")
    val out = pargs.getValue[String]("out")
    assert(!new File(out).exists())
    InterfaceAnalysis.get(Experiment(experimentId), app).foreach { analysis =>
      analysis.dumpScreenshot(out)
    }
    null
  }

}
